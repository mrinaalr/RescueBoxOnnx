# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-01-15T12:55:32+00:00

from __future__ import annotations

from enum import Enum
from pathlib import Path
from typing import Annotated, Any, Dict, List, Literal, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    DirectoryPath,
    Field,
    FilePath,
    RootModel,
    field_validator,
    model_validator,
)

API_APPMETDATA = "app_metadata"
API_ROUTES = "routes"
PLUGIN_SCHEMA_SUFFIX = "_schema"


class AppMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    info: Annotated[
        str, Field(description="Markdown content to render on the info page")
    ]
    author: str
    version: str
    name: Annotated[str, Field(examples=["Face Match App"])]
    plugin_name: Annotated[str, Field(examples=["facematch"])]
    gpu: Annotated[bool, Field(alias="gpu")] = False


class SchemaAPIRoute(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    task_schema: Annotated[str, Field(examples=["/tasks/{name_of_task}/task_schema"])]
    run_task: Annotated[str, Field(examples=["/tasks/{name_of_task}"])]
    short_title: Annotated[str, Field(examples=["{A short title for the task}"])]
    order: Annotated[int, Field(examples=[1])]


class FileInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    path: FilePath


class DirectoryInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    path: DirectoryPath


class FileFilterDirectory(DirectoryInput):
    """Find files with file_extensions in path directory."""

    model_config = ConfigDict(
        populate_by_name=True,
    )
    path: str
    file_extensions: List[str]

    @field_validator("path")
    @classmethod
    def validate_directory(cls, v):
        path = Path(v)

        if not path.exists():
            raise ValueError(f"validate directory: '{v}' does not exist.")
        if not path.is_dir():
            raise ValueError(f"validate directory: Path '{v}' is not a directory.")
        return v

    @model_validator(mode="after")
    def file_filter(self) -> "FileFilterDirectory":
        path_obj = Path(self.path)
        files = list(path_obj.glob("*"))
        if not files:
            raise ValueError(f"validate directory: Directory {path_obj} is empty.")
        number_of_matched_files = [
            f.name for f in files if f.suffix.lower() in self.file_extensions
        ]
        if len(number_of_matched_files) < 1:
            raise ValueError(
                f"validate directory: No file extensions matching {self.file_extensions} found in directory: {path_obj}"
            )
        return self


class TextInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    text: str


class BatchFileInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    files: List[FileInput]


class BatchTextInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    texts: List[TextInput]


class BatchDirectoryInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    directories: List[DirectoryInput]


class InputType(Enum):
    FILE = "file"
    DIRECTORY = "directory"
    TEXT = "text"
    TEXTAREA = "textarea"
    BATCHFILE = "batchfile"
    BATCHTEXT = "batchtext"
    BATCHDIRECTORY = "batchdirectory"


class NewFileInputType(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    default_name: Annotated[
        Optional[str], Field(alias="defaultName", examples=["my_file"])
    ] = None
    default_extension: Annotated[str, Field(alias="defaultExtension", examples=[".db"])]
    allowed_extensions: Annotated[
        Union[Literal["*"], List[str]], Field(alias="allowedExtensions")
    ]
    input_type: Annotated[Optional[Literal["newfile"]], Field(alias="inputType")] = (
        "newfile"
    )


class ParameterType(Enum):
    RANGED_FLOAT = "ranged_float"
    FLOAT = "float"
    ENUM = "enum"
    TEXT = "text"
    RANGED_INT = "ranged_int"
    INT = "int"


class FloatParameterDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter_type: Annotated[Optional[ParameterType], Field(alias="parameterType")] = (
        ParameterType.FLOAT
    )
    default: float


class EnumVal(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    label: Optional[str] = None
    key: Optional[str] = None


class EnumParameterDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter_type: Annotated[Optional[ParameterType], Field(alias="parameterType")] = (
        ParameterType.ENUM
    )
    enum_vals: Annotated[List[EnumVal], Field(alias="enumVals")]
    message_when_empty: Annotated[Optional[str], Field(alias="messageWhenEmpty")] = None
    default: str


class TextParameterDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter_type: Annotated[Optional[ParameterType], Field(alias="parameterType")] = (
        ParameterType.TEXT
    )
    default: str


class IntParameterDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter_type: Annotated[Optional[ParameterType], Field(alias="parameterType")] = (
        ParameterType.INT
    )
    default: int


class IntRangeDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: int
    max: int


class FloatRangeDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: float
    max: float


class FileType(Enum):
    IMG = "img"
    CSV = "csv"
    JSON = "json"
    TEXT = "text"
    AUDIO = "audio"
    VIDEO = "video"
    MARKDOWN = "markdown"


class FileResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["file"]] = "file"
    file_type: FileType
    path: str
    title: Optional[str] = None
    subtitle: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None # additional columns like prediction

class DirectoryResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["directory"]] = "directory"
    path: str
    title: str
    subtitle: Optional[str] = None


class MarkdownResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["markdown"]] = "markdown"
    value: str
    title: Optional[str] = None
    subtitle: Optional[str] = None


class TextResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["text"]] = "text"
    value: str
    title: Optional[str] = None
    subtitle: Optional[str] = None


class BatchFileResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["batchfile"]] = "batchfile"
    files: List[FileResponse]


class BatchTextResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["batchtext"]] = "batchtext"
    texts: List[TextResponse]


class BatchDirectoryResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    output_type: Optional[Literal["batchdirectory"]] = "batchdirectory"
    directories: List[DirectoryResponse]


class APIRoutes(RootModel[List[SchemaAPIRoute]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: List[SchemaAPIRoute]


class Input(
    RootModel[
        Union[
            FileInput,
            DirectoryInput,
            TextInput,
            BatchFileInput,
            BatchTextInput,
            BatchDirectoryInput,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        FileInput,
        DirectoryInput,
        TextInput,
        BatchFileInput,
        BatchTextInput,
        BatchDirectoryInput,
    ]


class InputSchema(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    key: str
    label: str
    subtitle: Optional[str] = ""
    input_type: Annotated[Union[InputType, NewFileInputType], Field(alias="inputType")]


class RangedFloatParameterDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter_type: Annotated[Optional[ParameterType], Field(alias="parameterType")] = (
        ParameterType.RANGED_FLOAT
    )
    range: FloatRangeDescriptor
    default: float


class RangedIntParameterDescriptor(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter_type: Annotated[Optional[ParameterType], Field(alias="parameterType")] = (
        ParameterType.RANGED_INT
    )
    range: IntRangeDescriptor
    default: int


class RequestBody(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inputs: Dict[str, Input]
    parameters: Dict[str, Any]


class ResponseBody(
    RootModel[
        Union[
            FileResponse,
            DirectoryResponse,
            MarkdownResponse,
            TextResponse,
            BatchFileResponse,
            BatchTextResponse,
            BatchDirectoryResponse,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        FileResponse,
        DirectoryResponse,
        MarkdownResponse,
        TextResponse,
        BatchFileResponse,
        BatchTextResponse,
        BatchDirectoryResponse,
    ]


class ParameterSchema(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    key: str
    label: str
    subtitle: Optional[str] = ""
    value: Union[
        RangedFloatParameterDescriptor,
        FloatParameterDescriptor,
        EnumParameterDescriptor,
        TextParameterDescriptor,
        RangedIntParameterDescriptor,
        IntParameterDescriptor,
    ]


class TaskSchema(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inputs: List[InputSchema]
    parameters: List[ParameterSchema]
